# 面试题

## 1.UDP 和 TCP 的特点和区别

```
用户数据报协议 UDP（User Datagram Protocol）：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议 TCP（Transmission Control Protocol）：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。
```



## 2.HTTP1.0/1.1/2.0

```
- HTTP1.0
  - 每次请求都需要与服务器建立一个 TCP 连接（即 3 次握手 4 次挥手），服务器完成请求处理后立即断开 TCP 连接
  - 发送端队首阻塞
  
- HTTP1.1
  - 支持长连接 Connection：Keep-Alive （HTTP/1.1 的默认模式使用带流水线的持久连接），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。
  - 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
  - 端点续传
  - 身份认证、状态管理和 Cache 缓存等机制相关的请求头和响应头

- HTTP2.0
  - 多路复用
  - 二进制分帧
  - 头部压缩
  - 服务器推送
```



## 3.对称加密和非对称加密

```
1. 对称加密：对称加密指的是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。常见的对称加密算法：DES、AES、3DES 等等。更不安全
2. 非对称加密：非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。常见的非对称加密算法：RSA、ECC，效率更低
```



## 4.XSS 与 CSRF

### XSS

```
Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

XSS 的防御措施：
1. 过滤转义输入输出
2. 避免使用 eval、new Function 等执行字符串的方法，除非确定字符串和用户输入无关
3. 使用 cookie 的 httpOnly 属性，加上了这个属性的 cookie 字段，js 是无法进行读写的
4. 使用 innerHTML、document.write 的时候，如果数据是用户输入的，那么需要对象关键字符进行过滤与转义
```



### CSRF

```
跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。

攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

CSRF 防御措施：
1. 检测 http referer 是否是同域名
2. 避免登录的 session 长时间存储在客户端中
3. 关键请求使用验证码或者 token 机制
```



## 5.跨域

```
跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。

同源策略：一个源指的是主机名、协议和端口号的组合，必须相同

1. jsonp 的原理就是利用<script>标签没有跨域限制，通过<script>标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。
2. CORS 是一个 W3C 标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制
3. nginx：a 网站向 b 网站请求 1.js 文件时，向 b 网站发送一个获取的请求，nginx 根据配置文件接收这个请求，代替 a 网站向 b 网站来请求这个资源，nginx 拿到这个资源后再返回给 a 网站，以此来解决了跨域问题
4. postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递
```



## 6.强缓存和协商缓存

```
1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码;

2.协商缓存：向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中（请求的资源未更新），则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源，如果资源更新则返回资源和状态码 200；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。
```



## 7.JS 数据类型

```javascript
基本类型（单类型）： String、Number、boolean、null、undefined、symbol。

引用类型：object。里面包含的 function、Array、Date。
```



## 8.检测数组类型的方法

检测数组类型的方法

- instanceof 操作符

 ![img](https://img-blog.csdnimg.cn/20210525170333706.png)

- 对象的 constructor 属性

 ![img](https://img-blog.csdnimg.cn/20210525170414977.png)

- Array.isArray( ) 检验值是否为数组

 ![img](https://img-blog.csdnimg.cn/20210525170450112.png)

## 9.判断 JS 数据类型的基本方法

### typeof

```javascript
typeof '';// string 有效

typeof 1;// number 有效

typeof Symbol();// symbol 有效

typeof true;//boolean 有效

typeof undefined;//undefined 有效

typeof null;//object 无效

typeof [] ;//object 无效

typeof new Function();// function 有效

typeof new Date();//object 无效

typeof new RegExp();//object 无效
```



### instanceof

判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。

### Constructor

![image-20230822151206763](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230822151206763.png)

### toString

![image-20230822151311898](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230822151311898.png)

## 10.闭包

```
1. 闭包就是子函数可以有权访问父函数的变量、父函数的父函数的变量、一直到全局变量。归根结底,就是利用 js 得词法(静态)作用域,即作用域链在函数创建的时候就确定了。

2. 子函数如果不被销毁,整条作用域链上的变量仍然保存在内存中。
```



## 11.this 的指向问题

```
1. 全局作用域、普通函数以及定时器中的 this 指向全局对象 window
2. 方法中的 this 指向的是调用它的对象
3. 构造函数中的 this 指向构造函数的实例
4. 箭头函数中没有绑定 this，this 为最近外层作用域下有定义的 this
5. call、apply、bind 可改变 this 指向
```



## 12.javascript 垃圾回收机制原理

```
解决内存的泄露，垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。

现在各大浏览器通常采用的垃圾回收机制有两种方法：标记清除，引用计数。

标记清除：js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为"进入环境"，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为"离开环境"。

引用计数：语言引擎有一张"引用表"，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。
```



## 13.如何创建 BFC

```
body 根元素

浮动元素：float 除 none 以外的值

绝对定位元素：position (absolute、fixed)

display 为 inline-block、table-cells、flex

overflow 除了 visible 以外的值 (hidden、auto、scroll)
```



## 14.CSS 选择器及优先级

```
内联样式>内部样式>外部样式>ID 选择器>类选择器 and 伪类选择器>标签（元素）选择器 and 伪元素选择器>通配符选择器
```

![image-20230822154008305](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230822154008305.png)

## 15.浏览器渲染机制

![image-20230823172001189](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230823172001189.png)

```
当用户输入一个URL时，浏览器就会向服务器发出一个请求，请求URL对应的资源

·  接受到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一棵DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成以后，才会去构建当前节点的下一个兄弟节点。

·  将CSS解析成CSSOM树（CSS Rule Tree）

·  根据DOM树和CSSOM树，来构建Render Tree（渲染树）,注意渲染树，并不等于DOM树，因为一些像head或display:none的东西，就没有必要放在渲染树中了。

·  有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义，以及它们的从属关系，下一步操作就是Layout,顾名思义，就是计算出每个节点在屏幕中的位置。

·  Layout后，浏览器已经知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置是哪里，就进入了最后一步painting,按照算出来的规则，通过显卡，把内容画到屏幕上。

 


·  Repaint重绘 ——改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

·  Reflow回流 ——元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。

·  reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。

· 减少回流重绘
使用class代替style，减少style的使用
·使用resize、scroll时进行防抖和节流处理，这两者会直接导致回流
·使用visibility替换display:none，因为前者只会引起重绘，后者会引发回流
·批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流
·避免触发同步布局事件，我们在获取offsetWidth这类的属性时，可以使用变量将查询结果存起来，避免多次查询，每次对offset / scroll /client等属性进行操作时都会触发回流
·对于复杂动画效果，使用绝对定位让其脱离文档流，复杂动画效果会频繁的触发回流和重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘。
```

## 16.前端性能优化的手段

```
·降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。

·加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发（多个地点分配服务器，加载快）。事件委托，防抖节流

·缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。不加载重复资源

·渲染：JS/CSS优化(css在头部，js在底部)，加载顺序，服务端渲染，pipeline。

```

## 17.节流防抖、图片懒/预加载

```
1.防抖：对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行最后一次。
·搜索框搜索输入。只需用户最后一次输入完，再发送请求
·手机号、邮箱验证输入检测
·窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

2.节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
·滚动加载，加载更多或滚到底部监听
·谷歌搜索框，搜索联想功能
·高频点击提交，表单重复提交

3.图片懒加载：懒加载就是优先加载可视区域的内容，其他部分等进入了可视区域在加载。
4.图片预加载：当图片加载过一次以后，如果再有对该图片的请求时，由于浏览器已经缓存住这张图片了，不会再发起一次新的请求，而是直接从缓存中加载过来。
```



## 18.margin合并

```
当两个元素在垂直方向并列，分别设置margin值会发生一个margin合并的现象
1.给父级盒子设置overflow:hidden
2.给父级盒子设置border
3.给父级盒子设置padding
4.给父元素添加position:absolute
5.给父元素添加position:fixed
6.给父元素添加display:inline-block
```

## 19.块、行内、行内块级

```
块级元素
1.总是从新的一行开始
2.高度、宽度都是可控的
3.宽度没有设置时，默认为100%
4.块级元素中包含块级元素和行内元素
5.块级文字元素中不能放入其他块级元素

行内元素
1.和其他元素在一行
2.高度、宽度以及内边距都是不可控的
3.宽高就是内容的高度，依靠自身字体大小和图形支撑结构的，不可以改变
4.行内元素只能行内元素，不能包含块级元素
5.行内元素的padding可以设置
6.margin只能够设置水平方向的编剧，即：margin-left和margin-right,设置margin-top和margin-bottom无效

行内块元素
综合块级元素和行内元素的特性，可设宽高(默认是内容宽高)，也可以设置内外边距
```

## 20.JavaScript阻止修改对象的三种方式

```
1.防止扩展
禁止为对象添加属性和方法。但已存在的属性和方法可以被修改或删除
实施操作：Object.preventExtensions()
检测是否应用该操作:Object.isExtensible()

2.密封:
禁止为对象删除已存在的属性和方法。被密封的对象也是不可扩展的
实施操作:Object.real()
检测是否应用该操作：Object.isSealed()

3.冻结:
禁止为对象修改已存在的属性和方法。所有字段均已读。被冻结的对象也是不可扩展和密封的
实施操作：Object.freeze()
检测是否应用该操作:Object.isFrozen()
```

## 21.javascript遍历对象总结

```
for...in
Object.keys()
Object.getOwnPropertyNames(obj)
```

## 22.css中单位em和rem的区别

```
在css中单位长度用的最多的是px、em、rem，这三个的区别是：
px是固定的像素，一旦设置了就无法因为适应页面大小而改变。
em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。
对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。
像素（px）：用于元素的边框或定位。
em/rem：用于做响应式页面
```

## 23.Map和forEach区别

```
1.map速度比foreach块
2.map会返回一个新数组，不对原数组产生影响，foreach不会产生新数组，foreach返回undefined
3.map因为返回数组所以可以链式操作，foreach不行
4.map里可以用return,而foreach里return不起作用，foreach不能用break
```

